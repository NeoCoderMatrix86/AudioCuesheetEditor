<!--
This file is part of AudioCuesheetEditor.

AudioCuesheetEditor is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

AudioCuesheetEditor is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Foobar.  If not, see
<http: //www.gnu.org/licenses />.
-->
@implements IDisposable

@inject SessionStateContainer _sessionStateContainer
@inject ITextLocalizer<RecordControl> _localizer
@inject ITextLocalizerService _localizationService
@inject LocalStorageOptionsProvider _localStorageOptionsProvider

@if (_sessionStateContainer.Cuesheet.IsRecording == true)
{
    var backgroundCSS = _sessionStateContainer.Cuesheet.IsRecording ? "BackgroundBlink rounded" : "rounded";
    <div class="@backgroundCSS">
        <Heading Size="HeadingSize.Is4" TextAlignment="TextAlignment.Center">@_localizer["Record running!"]</Heading>
    </div>
}
@if ((startRecordTimer != null) && (startRecordTimer.Enabled))
{
    <div class="BackgroundBlink rounded">
        <Heading Size="HeadingSize.Is4" TextAlignment="TextAlignment.Center">@_localizer["Record will start in {0} seconds!", ((startRecordTimer.Interval / 1000) - (DateTime.Now - recordTimerStarted).Seconds)]</Heading>
    </div>
}
<Row>
    <Column>
        <Dropdown Direction="Direction.End">
            <Button Color="Color.Danger" Clicked="StartRecordingClicked" Disabled="_sessionStateContainer.Cuesheet.IsRecording">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-record2" viewBox="0 0 16 16">
                    <path d="M8 12a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm0 1A5 5 0 1 0 8 3a5 5 0 0 0 0 10z" />
                    <path d="M10 8a2 2 0 1 1-4 0 2 2 0 0 1 4 0z" />
                </svg>
                @_localizer["Start recording"]
            </Button>
            <DropdownToggle Color="Color.Danger" Split="true"></DropdownToggle>
            <DropdownMenu>
                <DropdownItem Clicked="StartRecordCountdownTimer" Disabled="startRecordTimer == null || _sessionStateContainer.Cuesheet.IsRecording">@_localizer["Start record timer"]</DropdownItem>
            </DropdownMenu>
        </Dropdown>
    </Column>
    <Column>
        @if (_sessionStateContainer.Cuesheet.RecordingTime.HasValue == true)
        {
            <Heading Size="HeadingSize.Is4">@GetTimespanAsString(_sessionStateContainer.Cuesheet.RecordingTime, true)</Heading>
        }
        else
        {
            <Heading Size="HeadingSize.Is4">@String.Format("--{0}--{1}--", CultureInfo.CurrentCulture.DateTimeFormat.TimeSeparator, CultureInfo.CurrentCulture.DateTimeFormat.TimeSeparator)</Heading>
        }
    </Column>
    <Column>
        <Button Color="Color.Warning" Clicked="StopRecordingClicked" Disabled="!_sessionStateContainer.Cuesheet.IsRecording">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-stop-btn" viewBox="0 0 16 16">
                <path d="M6.5 5A1.5 1.5 0 0 0 5 6.5v3A1.5 1.5 0 0 0 6.5 11h3A1.5 1.5 0 0 0 11 9.5v-3A1.5 1.5 0 0 0 9.5 5h-3z" />
                <path d="M0 4a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V4zm15 0a1 1 0 0 0-1-1H2a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4z" />
            </svg>
            @_localizer["Stop recording"]
        </Button>
    </Column>
</Row>

<ModalDialog @ref="modalDialog" />

@code {
    //TODO: During countdown the StartRecord button is enabled, which allows the user to manually start the record
    //TODO: Display the current value of the RecordCountdownTimer
    //TODO: Allow the user to edit the default RecordCountdownTimer
    Timer updateGUITimer = new Timer(500);
    Timer? startRecordTimer;
    DateTime recordTimerStarted;
    ApplicationOptions? applicationOptions;

    ModalDialog? modalDialog;

    [Parameter]
    public EventCallback StartRecordClicked { get; set; }

    [Parameter]
    public EventCallback StopRecordClicked { get; set; }

    public void Dispose()
    {
        _localizationService.LocalizationChanged -= LocalizationService_LocalizationChanged;
        _sessionStateContainer.CuesheetChanged -= SessionStateContainer_CuesheetChanged;
        _localStorageOptionsProvider.OptionSaved -= LocalStorageOptionsProvider_OptionsSaved;
    }

    protected override async Task OnInitializedAsync()
    {
        base.OnInitialized();

        _localizationService.LocalizationChanged += LocalizationService_LocalizationChanged;
        _sessionStateContainer.CuesheetChanged += SessionStateContainer_CuesheetChanged;
        _localStorageOptionsProvider.OptionSaved += LocalStorageOptionsProvider_OptionsSaved;

        updateGUITimer.AutoReset = true;
        updateGUITimer.Elapsed += delegate
        {
            StateHasChanged();
            Boolean startRecordTimeEnabled = false;
            if (startRecordTimer != null)
            {
                startRecordTimeEnabled = startRecordTimer.Enabled;
            }
            if ((startRecordTimeEnabled == false) && (_sessionStateContainer.Cuesheet.IsRecording == false))
            {
                updateGUITimer.Stop();
            }
        };

        applicationOptions = await _localStorageOptionsProvider.GetOptions<ApplicationOptions>();
        startRecordTimer = new Timer(applicationOptions.RecordCountdownTimer * 1000);
        startRecordTimer.Elapsed += async delegate
        {
            await StartRecordingClicked();
            startRecordTimer.Stop();
        };
    }

    void LocalizationService_LocalizationChanged(object? sender, EventArgs args)
    {
        StateHasChanged();
    }

    void SessionStateContainer_CuesheetChanged(object? sender, EventArgs args)
    {
        StateHasChanged();
    }

    String GetTimespanAsString(TimeSpan? timeSpan, Boolean removeMilliseconds = false)
    {
        String resultString = String.Empty;
        if ((timeSpan != null) && (timeSpan.HasValue))
        {
            if (removeMilliseconds == true)
            {
                resultString = timeSpan.Value.Subtract(new TimeSpan(0, 0, 0, 0, timeSpan.Value.Milliseconds)).ToString();
            }
            else
            {
                resultString = timeSpan.Value.ToString();
            }
        }
        return resultString;
    }

    async Task StartRecordingClicked()
    {
        //Check for empty cuesheet and warn!
        if (_sessionStateContainer.Cuesheet.Tracks.Count > 0)
        {
            if (modalDialog != null)
            {
                modalDialog.Title = _localizer["Error"];
                modalDialog.Text = _localizer["Cuesheet already contains tracks. Recording is not possible, if tracks are present. Please save your work and start with a clean cuesheet."];
                modalDialog.ModalSize = ModalSize.Small;
                modalDialog.Mode = ModalDialog.DialogMode.Alert;
                await modalDialog.ShowModal();
            }
        }
        else
        {
            _sessionStateContainer.Cuesheet.StartRecording();
            updateGUITimer.Start();
            await StartRecordClicked.InvokeAsync();
        }
    }

    void StartRecordCountdownTimer()
    {
        recordTimerStarted = DateTime.Now;
        if (startRecordTimer != null)
        {
            startRecordTimer.Start();
        }
        updateGUITimer.Start();
    }

    async Task StopRecordingClicked()
    {
        var options = await _localStorageOptionsProvider.GetOptions<ApplicationOptions>();
        _sessionStateContainer.Cuesheet.StopRecording(options);
        await StopRecordClicked.InvokeAsync();
    }

    void LocalStorageOptionsProvider_OptionsSaved(object? sender, IOptions options)
    {
        if (options is ApplicationOptions applicationOption)
        {
            applicationOptions = applicationOption;
            if (startRecordTimer != null)
            {
                startRecordTimer.Interval = applicationOptions.RecordCountdownTimer * 1000;
            }
        }
    }
}
